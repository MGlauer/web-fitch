// @generated by Peggy 5.0.0.
//
// https://peggyjs.org/


class peg$SyntaxError extends SyntaxError {
    constructor(message, expected, found, location) {
        super(message);
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
    }

    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            const st = sources.find(s => s.source === this.location.source);
            if (st) {
                src = st.text.split(/\r\n|\n|\r/g);
            }
            const s = this.location.start;
            const offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
                ? this.location.source.offset(s)
                : s;
            const loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
                const e = this.location.end;
                const filler = "".padEnd(offset_s.line.toString().length, " ");
                const line = src[s.line - 1];
                const last = s.line === e.line ? e.column : line.length + 1;
                const hatLen = (last - s.column) || 1;
                str += "\n --> " + loc + "\n"
                    + filler + " |\n"
                    + offset_s.line + " | " + line + "\n"
                    + filler + " | " + "".padEnd(s.column - 1, " ")
                    + "".padEnd(hatLen, "^");
            } else {
                str += "\n at " + loc;
            }
        }
        return str;
    }

    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.codePointAt(0).toString(16).toUpperCase();
        }

        const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode")
            ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu")
            : null;
        function unicodeEscape(s) {
            if (nonPrintable) {
                return s.replace(nonPrintable,  ch => "\\u{" + hex(ch) + "}");
            }
            return s;
        }

        function literalEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/"/g,  "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g,          ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x"  + hex(ch)));
        }

        function classEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g,  "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g,          ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x"  + hex(ch)));
        }

        const DESCRIBE_EXPECTATION_FNS = {
            literal(expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
            },

            class(expectation) {
                const escapedParts = expectation.parts.map(
                    part => (Array.isArray(part)
                        ? classEscape(part[0]) + "-" + classEscape(part[1])
                        : classEscape(part))
                );

                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]" + (expectation.unicode ? "u" : "");
            },

            any() {
                return "any character";
            },

            end() {
                return "end of input";
            },

            other(expectation) {
                return expectation.description;
            },
        };

        function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
            const descriptions = expected.map(describeExpectation);
            descriptions.sort();

            if (descriptions.length > 0) {
                let j = 1;
                for (let i = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }

            switch (descriptions.length) {
                case 1:
                    return descriptions[0];

                case 2:
                    return descriptions[0] + " or " + descriptions[1];

                default:
                    return descriptions.slice(0, -1).join(", ")
                        + ", or "
                        + descriptions[descriptions.length - 1];
            }
        }

        function describeFound(found) {
            return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }
}

function peg$parse(input, options) {
    options = options !== undefined ? options : {};

    const peg$FAILED = {};
    const peg$source = options.grammarSource;

    const peg$startRuleFunctions = {
        start: peg$parsestart,
    };
    let peg$startRuleFunction = peg$parsestart;

    const peg$c0 = "(";
    const peg$c1 = ")";
    const peg$c2 = ",";
    const peg$c3 = "#";
    const peg$c4 = "\u22A5";
    const peg$c5 = "&";
    const peg$c6 = "|";
    const peg$c7 = ">";
    const peg$c8 = "<>";
    const peg$c9 = "~";
    const peg$c10 = "\xAC";
    const peg$c11 = "!";
    const peg$c12 = "?";

    const peg$r0 = /^[A-uw-z]/;
    const peg$r1 = /^[a-z]/;
    const peg$r2 = /^[\u2192\u2194\u2227-\u2228]/;
    const peg$r3 = /^[\u2200\u2203]/;

    const peg$e0 = peg$literalExpectation("(", false);
    const peg$e1 = peg$literalExpectation(")", false);
    const peg$e2 = peg$literalExpectation(",", false);
    const peg$e3 = peg$literalExpectation("#", false);
    const peg$e4 = peg$literalExpectation("\u22A5", false);
    const peg$e5 = peg$classExpectation([["A", "u"], ["w", "z"]], false, false, false);
    const peg$e6 = peg$classExpectation([["a", "z"]], false, false, false);
    const peg$e7 = peg$literalExpectation("&", false);
    const peg$e8 = peg$literalExpectation("|", false);
    const peg$e9 = peg$literalExpectation(">", false);
    const peg$e10 = peg$literalExpectation("<>", false);
    const peg$e11 = peg$classExpectation(["\u2192", "\u2194", ["\u2227", "\u2228"]], false, false, false);
    const peg$e12 = peg$literalExpectation("~", false);
    const peg$e13 = peg$literalExpectation("\xAC", false);
    const peg$e14 = peg$literalExpectation("!", false);
    const peg$e15 = peg$literalExpectation("?", false);
    const peg$e16 = peg$classExpectation(["\u2200", "\u2203"], false, false, false);

    function peg$f0(q, v, s) {    return {type:"quantSen", quant:q, vari:v, sen:s};  }
    function peg$f1(left, more) {    return flatten(left, more);  }
    function peg$f2(n, s) {return {type: "un", op:n, sen:s};  }
    function peg$f3(left) {return left;  }
    function peg$f4(pred, par) {if(!par){return {type:"atom", const:pred};}else{return {type: "pred", data:{pred:pred, terms:par[1]}}};  }
    function peg$f5() {return {type:"falsum"}  }
    function peg$f6() {return {type:"falsum"}  }
    function peg$f7(fun, par) {if(!par){return {type:"const", const:fun};}else{return {type: "fun", data:{fun:fun, terms:par[1]}};}  }
    function peg$f8() {return "\u2227"  }
    function peg$f9() {return "\u2228"  }
    function peg$f10() {return "\u2192"  }
    function peg$f11() {return "\u2194"  }
    function peg$f12() {return "\u00AC";  }
    function peg$f13() {return "\u2200"  }
    function peg$f14() {return "\u2203"  }
    let peg$currPos = options.peg$currPos | 0;
    let peg$savedPos = peg$currPos;
    const peg$posDetailsCache = [{ line: 1, column: 1 }];
    let peg$maxFailPos = peg$currPos;
    let peg$maxFailExpected = options.peg$maxFailExpected || [];
    let peg$silentFails = options.peg$silentFails | 0;

    let peg$result;

    if (options.startRule) {
        if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }

    function offset() {
        return peg$savedPos;
    }

    function range() {
        return {
            source: peg$source,
            start: peg$savedPos,
            end: peg$currPos,
        };
    }

    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
        location = location !== undefined
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos);

        throw peg$buildStructuredError(
            [peg$otherExpectation(description)],
            input.substring(peg$savedPos, peg$currPos),
            location
        );
    }

    function error(message, location) {
        location = location !== undefined
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos);

        throw peg$buildSimpleError(message, location);
    }

    function peg$getUnicode(pos = peg$currPos) {
        const cp = input.codePointAt(pos);
        if (cp === undefined) {
            return "";
        }
        return String.fromCodePoint(cp);
    }

    function peg$literalExpectation(text, ignoreCase) {
        return { type: "literal", text, ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase, unicode) {
        return { type: "class", parts, inverted, ignoreCase, unicode };
    }

    function peg$anyExpectation() {
        return { type: "any" };
    }

    function peg$endExpectation() {
        return { type: "end" };
    }

    function peg$otherExpectation(description) {
        return { type: "other", description };
    }

    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;

        if (details) {
            return details;
        } else {
            if (pos >= peg$posDetailsCache.length) {
                p = peg$posDetailsCache.length - 1;
            } else {
                p = pos;
                while (!peg$posDetailsCache[--p]) {}
            }

            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column,
            };

            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else {
                    details.column++;
                }

                p++;
            }

            peg$posDetailsCache[pos] = details;

            return details;
        }
    }

    function peg$computeLocation(startPos, endPos, offset) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);

        const res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column,
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column,
            },
        };
        if (offset && peg$source && (typeof peg$source.offset === "function")) {
            res.start = peg$source.offset(res.start);
            res.end = peg$source.offset(res.end);
        }
        return res;
    }

    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) { return; }

        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected, found),
            expected,
            found,
            location
        );
    }

    function peg$parsestart() {
        let s0;

        s0 = peg$parseSen();

        return s0;
    }

    function peg$parseSen() {
        let s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        s1 = peg$parsequant();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsefunctionConVarSym();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsePSen();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f0(s1, s2, s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePSen();
            if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$parsebinop();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsePSen();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$currPos;
                    s4 = peg$parsebinop();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsePSen();
                        if (s5 !== peg$FAILED) {
                            s4 = [s4, s5];
                            s3 = s4;
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                peg$savedPos = s0;
                s0 = peg$f1(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }

        return s0;
    }

    function peg$parsePSen() {
        let s0, s1, s2, s3;

        s0 = peg$currPos;
        s1 = peg$parseneg();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsePSen();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f2(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c0;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e0); }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parseSen();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s3 = peg$c1;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e1); }
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f3(s2);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$parseAtom();
            }
        }

        return s0;
    }

    function peg$parseAtom() {
        let s0, s1, s2, s3, s4, s5, s6, s7;

        s0 = peg$currPos;
        s1 = peg$parsepredicateSym();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c0;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e0); }
            }
            if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = [];
                s6 = peg$parseTerm();
                while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                        s7 = peg$c2;
                        peg$currPos++;
                    } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e2); }
                    }
                    if (s7 !== peg$FAILED) {
                        s7 = peg$parseTerm();
                        if (s7 === peg$FAILED) {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        } else {
                            s6 = s7;
                        }
                    } else {
                        s6 = s7;
                    }
                }
                if (s5.length < 1) {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                } else {
                    s4 = s5;
                }
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s5 = peg$c1;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e1); }
                    }
                    if (s5 !== peg$FAILED) {
                        s3 = [s3, s4, s5];
                        s2 = s3;
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f4(s1, s2);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
                s1 = peg$c3;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e3); }
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f5();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 8869) {
                    s1 = peg$c4;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e4); }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f6();
                }
                s0 = s1;
            }
        }

        return s0;
    }

    function peg$parseTerm() {
        let s0, s1, s2, s3, s4, s5, s6, s7;

        s0 = peg$currPos;
        s1 = peg$parsefunctionConVarSym();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c0;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e0); }
            }
            if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = [];
                s6 = peg$parseTerm();
                while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                        s7 = peg$c2;
                        peg$currPos++;
                    } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e2); }
                    }
                    if (s7 !== peg$FAILED) {
                        s7 = peg$parseTerm();
                        if (s7 === peg$FAILED) {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        } else {
                            s6 = s7;
                        }
                    } else {
                        s6 = s7;
                    }
                }
                if (s5.length < 1) {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                } else {
                    s4 = s5;
                }
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s5 = peg$c1;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e1); }
                    }
                    if (s5 !== peg$FAILED) {
                        s3 = [s3, s4, s5];
                        s2 = s3;
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f7(s1, s2);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parsepredicateSym() {
        let s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e5); }
        }
        if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = input.charAt(peg$currPos);
            if (peg$r0.test(s4)) {
                peg$currPos++;
            } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e5); }
            }
            while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = input.charAt(peg$currPos);
                if (peg$r0.test(s4)) {
                    peg$currPos++;
                } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e5); }
                }
            }
            s2 = [s2, s3];
            s1 = s2;
        } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        } else {
            s0 = s1;
        }

        return s0;
    }

    function peg$parsefunctionConVarSym() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r1.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e6); }
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = input.charAt(peg$currPos);
                if (peg$r1.test(s2)) {
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e6); }
                }
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        } else {
            s0 = s1;
        }

        return s0;
    }

    function peg$parsebinop() {
        let s0, s1;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c5;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e7); }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 124) {
                s1 = peg$c6;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e8); }
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f9();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 62) {
                    s1 = peg$c7;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e9); }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f10();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c8) {
                        s1 = peg$c8;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e10); }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$f11();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = input.charAt(peg$currPos);
                        if (peg$r2.test(s0)) {
                            peg$currPos++;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$e11); }
                        }
                    }
                }
            }
        }

        return s0;
    }

    function peg$parseneg() {
        let s0, s1;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 126) {
            s1 = peg$c9;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e12); }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f12();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 172) {
                s0 = peg$c10;
                peg$currPos++;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e13); }
            }
        }

        return s0;
    }

    function peg$parsequant() {
        let s0, s1;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c11;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e14); }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f13();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 63) {
                s1 = peg$c12;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e15); }
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f14();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = input.charAt(peg$currPos);
                if (peg$r3.test(s0)) {
                    peg$currPos++;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e16); }
                }
            }
        }

        return s0;
    }


    input = input.replaceAll(" ", "");
    function flatten(sen, more){
        let op = undefined;
        if(more.length == 0) return sen;
        let res = [sen];
        for(let i=0; i<more.length; i+=1){
            if(!op){op = more[i][0];};
            if(op != more[i][0]){
                throw peg$SyntaxError("Different operators on same level");
            }
            res.push(more[i][1])
        }
        let r = res[res.length-1]
        for(let i=res.length-2; i>=0; i--){
            r = {type:"bin", left:res[i], op:op, right:r}
        }
        return r
    }

    peg$result = peg$startRuleFunction();

    const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);
    function peg$throw() {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,
            peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
    }
    if (options.peg$library) {
        return /** @type {any} */ ({
            peg$result,
            peg$currPos,
            peg$FAILED,
            peg$maxFailExpected,
            peg$maxFailPos,
            peg$success,
            peg$throw: peg$success ? undefined : peg$throw,
        });
    }
    if (peg$success) {
        return peg$result;
    } else {
        peg$throw();
    }
}

const peg$allowedStartRules = [
    "start"
];

export {
    peg$allowedStartRules as StartRules,
    peg$SyntaxError as SyntaxError,
    peg$parse as parse
};